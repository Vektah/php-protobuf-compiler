<?php

{% if namespace %}
namespace {{ namespace }};

{% endif %}
use ProtobufMessage;
{% for use in uses %}
use {{ use }};
{% endfor %}

/**
 * THIS IS A GENERATED CLASS. DO NOT EDIT.
 *
 * generated from {{ sourceFilename }}
 *
{% for field in message.fields %}
 * @property {{ field.phpType }} ${{ field.identifier }}
{% endfor %}
 */
class {{ message.name }} extends {% if base %}{{ base.name }}{% else %}ProtobufMessage{% endif %}
{
    public $values = [];

    /** @var array lazy loaded field details built from buildFields() **/
    private $fields;

    /** @var array lazy loaded properties built from $fields. **/
    private $propToId;

    /** @return array This is passed off to the base ProtobufMessage class in getFields. */
    protected static function buildFields()
    {
        $data = [
{% for field in message.fields %}
            {{ field.index }} => [
                'name' => '{{ field.identifier }}',
                'type' => {{ field.allegroType }},
{% if field.repeated %}
                'repeated' => {{ field.repeated }},
{% else %}
                'required' => {{ field.required }},
{% endif %}
{% if field.default %}
                'default' => {{ field.default }},
{% endif %}
            ],
{% endfor %}
        ];

{% if base %}
        return array_merge(parent::buildFields(), $data);
{% else %}
        return $data;
{% endif %}
    }

    /**
     * Constructs new message container and initializes the default state
     */
    public function __construct()
    {
        $this->clear();
    }

    /**
     * @param string $prop the name of the property
     * @return int id of the named property
     */
    protected function propToId($prop)
    {
        if (!$this->propToId) {
            $this->propToId = [];

            foreach ($this->getFields() as $id => $field) {
                $this->propToId[$field['name']] = $id;
            }
        }

        if (!isset($this->propToId[$prop])) {
            return null;
        }

        return $this->propToId[$prop];
    }

    /**
     * Clears message values and sets default ones
     *
     * @return null
     */
    public function clear()
    {
        foreach ($this->getFields() as $id => $field) {
            if (isset($field['repeated'])) {
                $this->values[$id] = [];
            } else {
                $this->values[$id] = isset($field['default']) ? $field['default'] : null;
            }
        }
    }

    /**
     * Returns field descriptors
     *
     * @return array
     */
    public function getFields()
    {
        if (!$this->fields) {
            $this->fields = static::buildFields();
        }

        return $this->fields;
    }

    /**
     * Magic getter
     *
     * @param string $prop the param name being retreived
     *
     * @return mixed
     */
    public function __get($prop)
    {
        $id = $this->propToId($prop);
        if ($id === null) {
            throw new \InvalidArgumentException('$prop is not a valid field, valid fields are: [' . implode(', ', array_keys($this->propToId)) . ']');
        }

        return $this->getValue($this->propToId($prop));
    }

    /**
     * Magic setter
     *
     * @param string $prop the param name being set
     * @param mixed $value the new value
     */
    public function __set($prop, $value)
    {
        $id = $this->propToId($prop);

        if (is_array($value)) {
            $this->clearValues($id);
            foreach ($value as $element) {
                $this->appendValue($id, $element);
            }
        } else {
            $this->setValue($id, $value);
        }
    }

    /**
     * Checks if a property is set
     *
     * @param string $prop the param name being checked
     * @return bool true if the property exists
     */
    public function __isset($prop)
    {
        return $this->propToId($prop) !== null;
    }

    const _CLASS = __CLASS__;
}
